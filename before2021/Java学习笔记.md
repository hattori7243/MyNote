- 字符串string类型为不可变字符串，是一个引用类型，可共享。与c++可直接更改的char类型数组不同。类似于python
---

- 区别空串和null串。空串是一个确定的对象，可以作为一个对象进行调用。而在null上调用方法，会产生错误。
---

- 对输入流进行读取、对文件进行读取都需要构造一个Scanner对象

- 对输入流进行读取：Scanner in = new Scanner(System.in)

- 对文件进行读取:Scanner in = new Scanner (Paths.get("myfile.txt")
- 对文件进行写入需要构造一个PrintWriter对象:PrintWriter out = new PrintWriter("myfile.txt")
---

- Java不允许在嵌套块中定义两次变量
---

- 无goto语句，采用对循环标号并使用调至某个循环的break和continue语句
---

- 大数值运算使用BigInteger和BigDecimal类。不能直接使用运算符进行运算，需调用类中的方法
---

- for-each循环:for(variable:collection) statement。遍历整个数组，不用使用下标，无需为起始终止操心
---

- 命令行参数：main函数中的参数 String [] args。不包含程序名，直接数组第0个即传入的参数，以空格分隔。
---

- 多维不规则数组：数组的数组：
---

- 在类中不要编写返回引用可变对象的访问器方法，会破坏封装性。应该返回一个可变对象的拷贝
---

- 类中final关键字表示域必须在构造器中被初始化，且之后不能更改。但如果是一个对象的引用时，不代表该对象不能被更改，代表的只是对该对象的指向不能被更改。
---

- 静态是指属于类而不是如实例域属于某个对象
---

- 静态static+final定义静态常量
---

- 静态方法不能访问实例域，但是可以访问自身类中的静态域
---

- Java中方法参数为按值调用，无按引用调用。所以不能通过方法调用让对象参数引用到一个新的对象
---

- this调用本类的构造方法,super调用父类的构造方法。必须放在构造方法里的第一条语句，且只能有一条
---

- 初始化顺序
	- 根据类型初始化为默认值0,false,null
	- 递归调用父类构造函数，直至最高一层Object类
	- 执行域初始化语句与初始化块
	- 递归的调用构造器
---

- Java有自动的垃圾回收器，所以不需要也不允许析构器
---

- 类设计要点：
	- **保证数据的私有**
	- **要对对数据进行初始化**
	- 不要在类中使用过多的基本类型，不利于将来的重构
	- 不要为所有的域设置访问器和更改器
	- 将职责过多的类进行分解
	- 命名应体现职责
---

- 面向对象程序设计的重点：封装、继承、多态
---

- 虚方法的调用：自动的根据实例的类型决定调用对应的方法，Java中除了static和private默认是虚方法。
---

- 使用双大括号{{}}对类中字段进行初始化赋值
---

- 内部类：在类中定义的类。在其他地方使用时要冠以外部类的名字，创建时需要使用**外部对象名.new 内部类名**
---

- 局部类：在方法中定义的类。无public、protected、private修饰词，但可以被final和abstract修饰。不能访问方法中的局部变量，除非加了final
---

- 匿名类是一种特殊的内部类，一次性使用，在定义的同时就生成一个实例。
- 不取名字，一般直接用其父类或者接口的名字，不使用关键词class，也不用extends和implements
- 在构造对象时试用期父类的构造方法
---

- Lambda表达式：参数 -> 结果
- 实际上是匿名类的一个实例
- 最多只能有一个抽象函数
---

- 引用代替了指针，受控、安全。不能访问没有引用的内存，自动回收垃圾。
---

- 判断相等==时，对基本类型是判断值相等，引用类型是判断是否引用到同一个对象，对于string要用equals进行判断
- 字符串常量不用于字符串变量，有做内部化特殊处理
---

- is-a是继承关系的一个明显的特征，在java中，继承都是公有继承，即不能访问父类的私有域和方法，只能调用公共接口
---

- 子类一般需使用super调用父类的构造器完成构造，但如没有显示构造，则会调用父类的无参数的构造器
---

- 一个对象变量可以指示多种实际类型的现象被称为多态
- 可以将子类的引用赋给父类，但不可以将父类的引用赋给子类——即使本来是子类被赋给父类之后的父类。
---

- 在覆盖一个方法时，子类方法的可见性不能低于父类方法
---

-final类即将所有类中的方法定义为final方法，不允许被扩展，并没有将所有的域变为final
---

- 包含抽象方法的类本身必须是抽象的,且不能实例化
---

- 类中控制可见性的修饰符：
	- 默认，无修饰符：仅对本包可见
	- private：仅对本类可见
	- protected：对本包和子类可见
	- public：对所有类可见

- toString方法可以获得有关对象状态的必要信息
---

- 泛型数组列表ArrayList可以动态更改数组，无需在定义或运行时就指定数组的大小
- 但其只能对类型进行操作，不支持基本类型，可以将基本类型进行装箱或包装
- 用法：Arraylist<Employee> staff=new Arraylist();
- 方法：add();set();get();size();trimtosize();toArray();
---

- 自动装箱的包装器是不可变的，判断相等须使用equals方法
---

- 可变参数自动组成一个数组传进，用法：double...values变成double[] values
---

- 可以通过在jar文件中的清单文件中对类进行密封声明
---

- 注意在try-catch-finally中return的返回值问题
---

- 断言允许在测试期间向代码中加入一些检查语句，在发布代码后会被自动移走
---

- 在泛型类中，对参数接口的限定使用关键词extends而不是implement
---

- Java中集合类库的接口和实现是分离的
---








